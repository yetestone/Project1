//Problem I
//Time Limit : 1000 / 1000ms(Java / Other)   Memory Limit : 32768 / 32768K(Java / Other)
//Total Submission(s) : 84   Accepted Submission(s) : 33
//Problem Description
//时间：2008年5月16日（震后第4天）
//地点：汶川县牛脑寨
//人物：羌族老奶奶
//
//【转载整理】牛脑寨是一个全村600多人的羌族寨子，震后几天，这里依然能常常听到隆隆的声音，那是对面山上石头不断滑落的声音。在完成整个突击队的抢修移动基站的任务后，我提着相机开始记录这里的受创情况。
//突然，我的视线里出现一个羌族老人，这让我无比的震惊，要知道，那是一个极陡的坡，这个佝偻着腰的老人是怎么艰难地爬上来的？她上来做什么？
//
//
//老人背后是极陡的坡，她只有一只眼睛有依稀的视力，望着满地废墟，她徘徊了很久。家在哪里，她极力地用很低的视力找寻着。她曾经的家就在旁边，但是满目废墟已经让老人看不出来。她举目远眺，期望那里能看到家的一点点痕迹。原来家就在旁边，左手抓住一个房橼，努力让自己站住，地震过去三天了，她第一次回到曾经的家。
//
//
//一个倒塌的柜子，里面装着一丝希望，老人很吃力地搬动掩盖在柜子上的薪柴。老人找到一把木匠用的刨子，老泪纵横，或许有哪个逝去的亲人是木匠。睹物思人，逝者已矣。
//
//
//继续找，一把散碎的挂面出现在我的眼前。她颤颤巍巍地捞起铺满灰尘的挂面，再次流出了眼泪......
//看着她仔细地把挂面放进胸前的围腰里，我顿然感觉到，这是老人在得到外援之前赖以生存的口粮了，如果不是交通中断，外部救援进不来，老人家又何必拖着80多岁的躯体，强忍失去亲人的痛苦，重新回到这夺取她亲人生命的废墟，寻找这点点挂面？老人是真饿了......
//
//
//老人佝偻着腰，低声喃喃地念着那两句话“你们走了，我可怎么活”，拿着那对我们身处城市的人们微不足道的挂面，远去了......
//
//PS: 拍完这组照片后我才知道，5月14号军用运输飞机第一次给汶川空投救援物资就掉在牛脑寨，受灾的村民们没有占为己有，而是汗流浃背地走了两个小时背到山下的县城交给政府。
//	--------------------------------------------------------------------------------------------------------
//
//	对于幸存的灾民来说，最急待解决的显然是温饱问题，救灾部队一边在组织人员全力打通交通，一边在组织采购粮食。现在假设下拨了一定数量的救灾经费要去市场采购大米（散装）。如果市场有m种大米，各种大米的单价和重量已知，请问，为了满足更多灾民的需求，最多能采购多少重量的大米呢？
//
//
//	Input
//	输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m（0<n <= 1000, 0<m <= 1000）, 分别表示经费的金额和大米的种类，然后是m行数据，每行包含2个整数p和h(1 <= p <= 25, 1 <= h <= 100)，分别表示单价和对应大米的重量。
//
//
//	Output
//	对于每组测试数据，请输出能够购买大米的最多重量（你可以假设经费买不光所有的大米）。 每个实例的输出占一行，保留2位小数。
//
//
//	Sample Input
//	1
//	7 2
//	3 3
//	4 4
//
//
//	Sample Output
//	2.33
//



#include<stdio.h>
#include<stdlib.h>
typedef struct test
{
	int p;
	int h;
//	double mmm;
} STR;


int cmp(const void *a, const void *b)
{
	STR *aa = (STR *)a;
	STR *bb = (STR *)b;
	return(((aa->p)>(bb->p)) ? 1 : -1);
}

int main()
{
	int T;
	scanf("%d", &T);
	while (T--)
	{
		int money;
		int sort;
		STR a[1001];
		int i;
		double buy=0.0;
		scanf("%d %d", &money, &sort);
		for (i = 0; i < sort; i++)
		{
			scanf("%d %d", &a[i].p, &a[i].h);
//			a[i].mmm = (double)a[i].h / a[i].p;
		}
		qsort(a, sort, sizeof(a[0]), cmp);
		for (i = 0; i < sort; i++)
		{
			if (a[i].h*a[i].p <= money)
			{
				buy += a[i].h;
				money -= a[i].h*a[i].p;
			}
			else
			{
				buy += money * (double)1 / a[i].p;
				break;
			}
		}
		printf("%.2f\n", buy);
	}
}